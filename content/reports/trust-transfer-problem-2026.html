<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Trust Transfer Problem — Ainary Report AR-024</title>
<style>
  /* ========================================
     FONTS
     ======================================== */
  @font-face {
    font-family: 'Inter';
    src: url('/fonts/inter-variable.woff2') format('woff2');
    font-weight: 100 900;
    font-display: swap;
  }

  /* ========================================
     RESET & BASE
     ======================================== */
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    background: #fafaf8;
    color: #333;
    line-height: 1.75;
    font-size: 0.95rem;
    font-weight: 400;
  }

  /* ========================================
     LAYOUT
     ======================================== */
  .page {
    max-width: 900px;
    margin: 0 auto;
    padding: 48px 40px;
  }

  .cover {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    max-width: 900px;
    margin: 0 auto;
    padding: 48px 40px;
  }

  .back-cover {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    max-width: 900px;
    margin: 0 auto;
    padding: 48px 40px;
    page-break-before: always;
  }

  /* ========================================
     TYPOGRAPHY
     ======================================== */
  h1 {
    font-size: 2.2rem;
    font-weight: 600;
    line-height: 1.2;
    color: #1a1a1a;
    letter-spacing: -0.02em;
  }

  h2 {
    font-size: 1.5rem;
    font-weight: 600;
    color: #1a1a1a;
    line-height: 1.3;
    margin-top: 3rem;
    margin-bottom: 12px;
  }

  h3 {
    font-size: 1.1rem;
    font-weight: 600;
    color: #1a1a1a;
    line-height: 1.4;
    margin-top: 2rem;
    margin-bottom: 12px;
  }

  p {
    margin-bottom: 1rem;
  }

  strong {
    font-weight: 600;
    color: #1a1a1a;
  }

  em {
    font-style: italic;
  }

  sup {
    font-size: 0.65rem;
    color: #888;
    vertical-align: super;
  }

  /* ========================================
     COVER COMPONENTS
     ======================================== */
  .cover-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 40vh;
  }

  .cover-brand {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .gold-punkt {
    color: #c8aa50;
    font-size: 14px;
  }

  .brand-name {
    font-size: 0.85rem;
    font-weight: 500;
    color: #1a1a1a;
    letter-spacing: 0.02em;
  }

  .cover-meta {
    display: flex;
    gap: 12px;
    font-size: 0.75rem;
    color: #888;
  }

  .cover-title-block {
    margin-bottom: auto;
  }

  .cover-title {
    margin-bottom: 16px;
  }

  .cover-subtitle {
    font-size: 1rem;
    font-weight: 400;
    color: #666;
    line-height: 1.5;
  }

  .cover-footer {
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
  }

  .cover-date {
    font-size: 0.75rem;
    color: #888;
  }

  .cover-author {
    font-size: 0.75rem;
    color: #888;
    text-align: center;
  }

  /* ========================================
     QUOTE PAGE
     ======================================== */
  .quote-page {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    max-width: 700px;
    margin: 0 auto;
    padding: 48px 40px;
  }

  .quote-text {
    font-size: 1.2rem;
    font-style: italic;
    color: #333;
    line-height: 1.8;
    text-align: center;
    margin-bottom: 24px;
  }

  .quote-source {
    font-size: 0.85rem;
    color: #888;
    text-align: center;
  }

  /* ========================================
     TABLE OF CONTENTS
     ======================================== */
  .toc-label {
    font-size: 0.7rem;
    font-weight: 600;
    color: #1a1a1a;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    margin-bottom: 24px;
  }

  .toc-section {
    margin-bottom: 32px;
  }

  .toc-section-label {
    font-size: 0.65rem;
    font-weight: 500;
    color: #888;
    text-transform: uppercase;
    letter-spacing: 0.12em;
    margin-bottom: 12px;
  }

  .toc-entry {
    display: flex;
    align-items: baseline;
    gap: 16px;
    padding: 12px 0;
    border-bottom: 1px solid #eee;
    text-decoration: none;
    transition: all 0.2s;
  }

  .toc-number {
    font-size: 0.8rem;
    color: #888;
    font-variant-numeric: tabular-nums;
    min-width: 24px;
  }

  .toc-title {
    font-size: 0.95rem;
    font-weight: 500;
    color: #1a1a1a;
    flex: 1;
    transition: color 0.2s;
  }

  .toc-entry:hover .toc-title {
    color: #c8aa50;
  }

  .toc-page {
    font-size: 0.8rem;
    color: #888;
  }

  /* ========================================
     HOW TO READ
     ======================================== */
  .how-to-read-table {
    width: 100%;
    border-collapse: collapse;
    margin: 24px 0;
  }

  .how-to-read-table th {
    text-align: left;
    font-size: 0.7rem;
    font-weight: 600;
    color: #555;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    padding: 10px 12px;
    background: #f5f4f0;
    border-bottom: 2px solid #e5e3dc;
  }

  .how-to-read-table td {
    font-size: 0.85rem;
    color: #333;
    padding: 10px 12px;
    border-bottom: 1px solid #ddd;
  }

  /* ========================================
     EXECUTIVE SUMMARY
     ======================================== */
  .thesis {
    font-size: 1rem;
    font-weight: 600;
    color: #1a1a1a;
    line-height: 1.6;
    margin-bottom: 24px;
  }

  .evidence-list {
    margin-left: 20px;
    margin-bottom: 24px;
  }

  .evidence-list li {
    font-size: 0.9rem;
    color: #333;
    line-height: 1.6;
    margin-bottom: 8px;
  }

  .keywords {
    font-size: 0.8rem;
    color: #666;
    font-style: italic;
    margin-top: 32px;
    padding-top: 16px;
    border-top: 1px solid #eee;
  }

  /* ========================================
     SECTION COMPONENTS
     ======================================== */
  .confidence-badge {
    font-size: 0.75rem;
    font-weight: 500;
    color: #1a1a1a;
    background: #f5f4f0;
    padding: 3px 8px;
    border-radius: 10px;
    margin-left: 8px;
    vertical-align: middle;
  }

  .confidence-line {
    font-size: 0.8rem;
    color: #888;
    font-style: italic;
    display: block;
    margin-bottom: 16px;
  }

  .key-insight {
    font-weight: 600;
    color: #1a1a1a;
  }

  /* ========================================
     CALLOUTS
     ======================================== */
  .callout {
    background: #f5f4f0;
    padding: 16px 20px;
    border-radius: 4px;
    margin: 1.5rem 0;
    page-break-inside: avoid;
  }

  .callout-label {
    font-size: 0.7rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    margin-bottom: 8px;
  }

  .callout-body {
    font-size: 0.9rem;
    color: #555;
    line-height: 1.6;
  }

  .callout.claim .callout-label {
    color: #555;
  }

  .callout.invalidation {
    border-left: 3px solid #ddd;
  }

  .callout.invalidation .callout-label {
    color: #888;
  }

  .callout.sowhat {
    border-left: 3px solid #c8aa50;
  }

  .callout.sowhat .callout-label {
    color: #c8aa50;
  }

  /* ========================================
     EXHIBITS & TABLES
     ======================================== */
  .exhibit {
    margin: 2rem 0;
  }

  .exhibit-label {
    font-size: 0.75rem;
    font-weight: 600;
    color: #555;
    margin-bottom: 12px;
  }

  .exhibit-table {
    width: 100%;
    border-collapse: collapse;
    page-break-inside: avoid;
  }

  .exhibit-table th {
    text-align: left;
    font-size: 0.7rem;
    font-weight: 600;
    color: #555;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    padding: 10px 12px;
    background: #f5f4f0;
    border-bottom: 2px solid #e5e3dc;
  }

  .exhibit-table td {
    font-size: 0.85rem;
    color: #333;
    padding: 10px 12px;
    border-bottom: 1px solid #ddd;
  }

  .exhibit-source {
    font-size: 0.7rem;
    color: #888;
    margin-top: 8px;
    font-style: italic;
  }

  /* ========================================
     KPI FIGURES
     ======================================== */
  .kpi-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 48px;
    margin: 2rem 0;
  }

  .kpi {
    text-align: left;
  }

  .kpi-number {
    font-size: 2rem;
    font-weight: 600;
    color: #1a1a1a;
    line-height: 1.2;
  }

  .kpi-label {
    font-size: 0.75rem;
    color: #666;
    margin-top: 4px;
  }

  .kpi-source {
    font-size: 0.65rem;
    color: #888;
    margin-top: 2px;
  }

  /* ========================================
     LISTS
     ======================================== */
  ul {
    margin-left: 20px;
    margin-bottom: 1rem;
  }

  ol {
    margin-left: 20px;
    margin-bottom: 1rem;
  }

  li {
    margin-bottom: 4px;
  }

  /* ========================================
     TRANSPARENCY NOTE
     ======================================== */
  .transparency-intro {
    font-size: 0.85rem;
    color: #555;
    line-height: 1.6;
    margin-bottom: 12px;
  }

  .transparency-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 12px;
  }

  .transparency-table td:first-child {
    font-size: 0.85rem;
    font-weight: 600;
    color: #555;
    padding: 8px 0;
    border-bottom: 1px solid #eee;
    width: 160px;
    vertical-align: top;
  }

  .transparency-table td:last-child {
    font-size: 0.85rem;
    color: #333;
    padding: 8px 0;
    border-bottom: 1px solid #eee;
  }

  /* ========================================
     REFERENCES
     ======================================== */
  .reference-entry {
    font-size: 0.8rem;
    color: #555;
    line-height: 1.5;
    margin-bottom: 6px;
    padding-left: 24px;
    text-indent: -24px;
  }

  /* ========================================
     AUTHOR BIO
     ======================================== */
  .author-section {
    margin-top: 3rem;
    padding-top: 2rem;
    border-top: 1px solid #e5e3dc;
  }

  .author-initials {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    background: #e5e3dc;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 0.9rem;
    font-weight: 600;
    color: #1a1a1a;
    margin-bottom: 12px;
  }

  .author-name {
    font-size: 0.95rem;
    font-weight: 600;
    color: #1a1a1a;
    margin-bottom: 8px;
  }

  .author-bio {
    font-size: 0.85rem;
    color: #555;
    line-height: 1.6;
    margin-bottom: 12px;
  }

  .author-link {
    font-size: 0.85rem;
    color: #888;
    text-decoration: none;
  }

  /* ========================================
     BACK COVER
     ======================================== */
  .back-cover-logo {
    margin-bottom: 24px;
  }

  .back-cover-services {
    font-size: 0.85rem;
    color: #666;
    margin-bottom: 24px;
  }

  .back-cover-cta {
    font-size: 0.85rem;
    color: #888;
    margin-bottom: 16px;
  }

  .back-cover-cta a {
    color: #888;
    text-decoration: none;
  }

  .back-cover-contact {
    font-size: 0.8rem;
    color: #888;
    margin-bottom: 32px;
  }

  .back-cover-copyright {
    font-size: 0.75rem;
    color: #aaa;
  }

  /* ========================================
     PRINT STYLES
     ======================================== */
  @media print {
    @page {
      size: A4;
      margin: 2cm;
    }

    body {
      background: white;
    }

    .page, .cover, .back-cover {
      page-break-after: always;
    }

    .callout, .exhibit {
      page-break-inside: avoid;
    }

    @page :first {
      @top-center { content: none; }
      @bottom-center { content: none; }
    }

    @page {
      @top-center {
        content: "Ainary Report | The Trust Transfer Problem";
        font-size: 0.7rem;
        color: #888;
      }
      @bottom-left {
        content: "© 2026 Ainary Ventures";
        font-size: 0.7rem;
        color: #888;
      }
      @bottom-right {
        content: counter(page);
        font-size: 0.7rem;
        color: #888;
      }
    }
  }
</style>
</head>
<body>

<!-- ========================================
     COVER PAGE
     ======================================== -->
<div class="cover">
  <div class="cover-header">
    <div class="cover-brand">
      <span class="gold-punkt">●</span>
      <span class="brand-name">Ainary</span>
    </div>
    <div class="cover-meta">
      <span>AR-024</span>
      <span>Confidence: 75%</span>
    </div>
  </div>

  <div class="cover-title-block">
    <h1 class="cover-title">The Trust Transfer Problem</h1>
    <p class="cover-subtitle">When Agents Delegate to Agents</p>
  </div>

  <div class="cover-footer">
    <div class="cover-date">
      February 2026<br>
      <span style="font-size: 0.7rem; color: #aaa;">v1.0</span>
    </div>
    <div class="cover-author">
      Florian Ziesche · Ainary Ventures
    </div>
  </div>
</div>

<!-- ========================================
     QUOTE PAGE
     ======================================== -->
<div class="quote-page">
  <p class="quote-text">"OAuth was designed for humans. It assumes persistent sessions and user consent—not fast-moving, autonomous systems."</p>
  <p class="quote-source">— Strata Identity, Agentic AI Security Guide (January 2026)</p>
</div>

<!-- ========================================
     TABLE OF CONTENTS
     ======================================== -->
<div class="page">
  <p class="toc-label">Contents</p>

  <div class="toc-section">
    <p class="toc-section-label">FOUNDATION</p>
    <a href="#how-to-read" class="toc-entry">
      <span class="toc-number">1</span>
      <span class="toc-title">How to Read This Report</span>
    </a>
    <a href="#exec-summary" class="toc-entry">
      <span class="toc-number">2</span>
      <span class="toc-title">Executive Summary</span>
    </a>
    <a href="#methodology" class="toc-entry">
      <span class="toc-number">3</span>
      <span class="toc-title">Methodology</span>
    </a>
  </div>

  <div class="toc-section">
    <p class="toc-section-label">ANALYSIS</p>
    <a href="#pki-analogy" class="toc-entry">
      <span class="toc-number">4</span>
      <span class="toc-title">The PKI Analogy — How Trust Chains Work (And Break)</span>
    </a>
    <a href="#transitive-trust" class="toc-entry">
      <span class="toc-number">5</span>
      <span class="toc-title">The Transitive Trust Fallacy</span>
    </a>
    <a href="#delegation-gap" class="toc-entry">
      <span class="toc-number">6</span>
      <span class="toc-title">The Delegation Gap — What OAuth Can't Do</span>
    </a>
    <a href="#framework-reality" class="toc-entry">
      <span class="toc-number">7</span>
      <span class="toc-title">The Framework Reality — No Trust Verification</span>
    </a>
    <a href="#emerging-solutions" class="toc-entry">
      <span class="toc-number">8</span>
      <span class="toc-title">Emerging Solutions — What's Being Built</span>
    </a>
  </div>

  <div class="toc-section">
    <p class="toc-section-label">ACTION</p>
    <a href="#recommendations" class="toc-entry">
      <span class="toc-number">9</span>
      <span class="toc-title">Recommendations</span>
    </a>
    <a href="#predictions" class="toc-entry">
      <span class="toc-number">10</span>
      <span class="toc-title">Predictions</span>
    </a>
    <a href="#transparency" class="toc-entry">
      <span class="toc-number">11</span>
      <span class="toc-title">Transparency Note</span>
    </a>
    <a href="#claim-register" class="toc-entry">
      <span class="toc-number">12</span>
      <span class="toc-title">Claim Register</span>
    </a>
    <a href="#references" class="toc-entry">
      <span class="toc-number">13</span>
      <span class="toc-title">References</span>
    </a>
  </div>
</div>

<!-- ========================================
     HOW TO READ THIS REPORT
     ======================================== -->
<div class="page" id="how-to-read">
  <h2>1. How to Read This Report</h2>

  <p>This report uses a structured confidence rating system to communicate what is known versus what is inferred. Every quantitative claim carries its source and confidence level.</p>

  <table class="how-to-read-table">
    <tr>
      <th>Rating</th>
      <th>Meaning</th>
      <th>Example</th>
    </tr>
    <tr>
      <td>High</td>
      <td>Multiple independent sources, established cryptographic principles or empirical data</td>
      <td>PKI transitive trust model (RFC standards + 30+ years deployment history)</td>
    </tr>
    <tr>
      <td>Medium</td>
      <td>Single credible source, emerging standards or documented implementation</td>
      <td>Visa Trusted Agent Protocol (GitHub repo + technical blog, not yet widely deployed)</td>
    </tr>
    <tr>
      <td>Low</td>
      <td>Theoretical analysis, extrapolation from related domains, or single early-stage tool</td>
      <td>Agent delegation attack vectors (inferred from PKI history, not yet documented in wild)</td>
    </tr>
  </table>

  <p style="margin-top: 24px;">This report was produced using a <strong>multi-agent research pipeline</strong> synthesizing cryptographic standards (PKI, OAuth, DPoP), multi-agent framework documentation, and emerging agent identity protocols. Full methodology details are provided in the Transparency Note (Section 11).</p>
</div>

<!-- ========================================
     EXECUTIVE SUMMARY
     ======================================== -->
<div class="page" id="exec-summary">
  <h2>2. Executive Summary</h2>

  <p class="thesis">Trust doesn't transfer transitively. When Agent A delegates to Agent B, the trust chain breaks in ways current architectures can't handle. We have 30 years of PKI teaching us how delegation chains fail — and we're ignoring every lesson.</p>

  <ul class="evidence-list">
    <li><strong>PKI solves transitive trust through cryptographic chain-of-trust verification</strong> — root CA → intermediate CA → end entity, with each link cryptographically signed and independently verifiable<sup>[1][2]</sup></li>
    <li><strong>OAuth 2.0 was designed for human users with persistent sessions</strong>, not autonomous agents that delegate tasks in milliseconds without user consent<sup>[3]</sup></li>
    <li><strong>No major multi-agent framework (AutoGen, CrewAI, MetaGPT, LangGraph) implements cryptographic delegation chain verification</strong> — messages between agents are trusted by default<sup>[4][5]</sup></li>
    <li><strong>Emerging standards (Visa Trusted Agent Protocol, DID/VC for agents, AAP Protocol) introduce cryptographic proof-of-possession</strong>, but adoption remains early-stage<sup>[6][7][8]</sup></li>
    <li><strong>The confused deputy attack—where Agent B misuses Agent A's authority—has no technical mitigation in current agent architectures</strong>, only policy-based controls<sup>[9]</sup></li>
  </ul>

  <p class="keywords"><strong>Keywords:</strong> Trust delegation, transitive trust, PKI chain-of-trust, multi-agent security, OAuth limitations, proof-of-possession, DID verifiable credentials, confused deputy attacks</p>
</div>

<!-- ========================================
     METHODOLOGY
     ======================================== -->
<div class="page" id="methodology">
  <h2>3. Methodology</h2>

  <p>This report synthesizes 15 sources: 4 cryptographic standards (PKI chain-of-trust, OAuth 2.0 RFC 8693 Token Exchange, DPoP RFC 9449, OpenID Federation), 6 framework documentation reviews (AutoGen, CrewAI, LangGraph, A2A protocol, Visa Trusted Agent Protocol, AAP Protocol), and 5 emerging agent identity implementations (DID/VC for agents, JSIGN, TessPay, OpenID Connect for Agents).</p>

  <p>Research followed a structured multi-agent pipeline: (1) PKI and OAuth delegation mechanism analysis, (2) Multi-agent framework security feature review, (3) Emerging agent identity protocol synthesis, (4) Gap analysis identifying where transitive trust breaks in current architectures, (5) Attack vector modeling based on historical PKI compromise patterns.</p>

  <p><strong>Limitations:</strong> Agent delegation security is an emerging field. Most "agent-to-agent trust" research is theoretical or early-implementation. Production incident data is scarce because organizations do not publicly disclose multi-agent delegation failures. The claim that "trust chains break" is supported by PKI analogy and framework analysis, but direct empirical evidence of agent delegation attacks in production is limited.</p>

  <p style="font-size: 0.85rem; color: #666; margin-top: 16px;">Full methodology details, including confidence calibration and source assessment, are provided in the Transparency Note (Section 11).</p>
</div>

<!-- ========================================
     SECTION 4: PKI ANALOGY
     ======================================== -->
<div class="page" id="pki-analogy">
  <h2>4. The PKI Analogy — How Trust Chains Work (And Break)
    <span class="confidence-badge">90%</span>
  </h2>
  <span class="confidence-line">(Confidence: High)</span>

  <p><span class="key-insight">Public Key Infrastructure (PKI) has spent 30 years solving the exact problem multi-agent systems now face: how do you verify trust when A delegates authority to B, and B acts on behalf of A? The answer: cryptographic chains with independent verification at every link.</span></p>

  <h3>How PKI Solves Delegation</h3>

  <p>When you visit https://example.com, your browser verifies a certificate chain<sup>[1][2]</sup>:</p>

  <ol>
    <li><strong>Root CA:</strong> A globally trusted Certificate Authority (e.g., DigiCert, Let's Encrypt) — the "trust anchor"</li>
    <li><strong>Intermediate CA:</strong> The Root CA delegates signing authority to an Intermediate CA, which handles day-to-day certificate issuance</li>
    <li><strong>End Entity Certificate:</strong> The Intermediate CA signs example.com's certificate</li>
  </ol>

  <p>Your browser trusts example.com not because it trusts example.com directly, but because it can cryptographically verify the chain: Root CA signed Intermediate CA, Intermediate CA signed example.com. Each signature is independently verifiable. The trust is transitive <strong>only because each link is cryptographically proven.</strong></p>

  <div class="exhibit">
    <p class="exhibit-label">Exhibit 1: PKI Chain of Trust vs. Agent Delegation (Current State)</p>
    <table class="exhibit-table">
      <tr>
        <th>Dimension</th>
        <th>PKI Chain of Trust</th>
        <th>Multi-Agent Delegation (Current)</th>
      </tr>
      <tr>
        <td>Trust anchor</td>
        <td>Root CA (globally recognized, audited)</td>
        <td>Undefined (implicit: whoever deployed the system)</td>
      </tr>
      <tr>
        <td>Delegation proof</td>
        <td>Cryptographic signature on certificate</td>
        <td>None (Agent B "trusts" messages from Agent A by default)</td>
      </tr>
      <tr>
        <td>Verification</td>
        <td>Each party independently validates full chain</td>
        <td>No chain validation (Agent B assumes Agent A is authorized)</td>
      </tr>
      <tr>
        <td>Revocation</td>
        <td>CRL (Certificate Revocation List), OCSP</td>
        <td>None (compromised agent remains trusted until manual removal)</td>
      </tr>
      <tr>
        <td>Scope limitation</td>
        <td>Certificate constraints (domain, validity period)</td>
        <td>Policy-based (not cryptographically enforced)</td>
      </tr>
      <tr>
        <td>Audit trail</td>
        <td>Certificate Transparency logs (public, tamper-evident)</td>
        <td>Application logs (if implemented, not standardized)</td>
      </tr>
    </table>
    <p class="exhibit-source">Source: PKI standards (RFC 5280) [1], Fir3net PKI overview [2], TraceSecurity chain-of-trust [10], multi-agent framework analysis [4][5]</p>
  </div>

  <h3>Where PKI Trust Chains Have Broken</h3>

  <p>PKI's 30-year history provides a catalogue of delegation failures that directly parallel emerging agent risks<sup>[11]</sup>:</p>

  <ul>
    <li><strong>2011 Comodo incident:</strong> A compromised Registration Authority (delegated partner) issued 9 rogue certificates for Google, Yahoo, Skype without proper domain verification. Attackers used stolen credentials to request certificates. The delegation chain was intact cryptographically, but the <strong>authority to delegate was compromised</strong>.<sup>[11]</sup></li>
    <li><strong>2011 DigiNotar breach:</strong> Complete CA compromise led to 500+ fraudulent certificates. Browsers had to distrust the entire CA. The lesson: <strong>compromise at any link invalidates the entire chain</strong>.<sup>[11]</sup></li>
    <li><strong>Symantec 2015-2017:</strong> Mis-issued 30,000+ certificates. Google and Mozilla progressively distrusted Symantec certificates, forcing migration to new CAs. The lesson: <strong>trust is not permanent—it requires continuous validation</strong>.<sup>[11]</sup></li>
  </ul>

  <p>Each failure led to architectural improvements: Certificate Transparency (public audit logs), stricter CA auditing, automated revocation. The PKI ecosystem learned: <strong>delegation requires not just authentication, but continuous verification and revocation mechanisms.</strong></p>

  <h3>The Agent Parallel</h3>

  <p>Multi-agent systems face identical risks:</p>

  <ul>
    <li>Agent A (the "Root CA") delegates task execution to Agent B (the "Intermediate CA")</li>
    <li>Agent B acts on behalf of Agent A, calling tools, accessing data, delegating to Agent C</li>
    <li>Downstream systems (Agent C, external APIs, databases) must decide: <strong>does Agent B really have authority to act on Agent A's behalf?</strong></li>
  </ul>

  <p>Current answer: "If Agent B says it's authorized, we trust it." This is equivalent to PKI without certificate verification—a system where anyone can claim to be signed by a Root CA and you just believe them.</p>

  <div class="callout claim">
    <p class="callout-label">Claim</p>
    <p class="callout-body">Multi-agent delegation without cryptographic chain-of-trust verification is functionally equivalent to PKI without certificate validation. The architecture assumes trust instead of proving it.</p>
  </div>

  <div class="callout invalidation">
    <p class="callout-label">What Would Invalidate This?</p>
    <p class="callout-body">If multi-agent frameworks shipped with built-in cryptographic delegation chains (message signing, provenance verification, revocation support) as default behavior, the "no trust verification" claim would weaken. Current frameworks have no such primitives.</p>
  </div>

  <div class="callout sowhat">
    <p class="callout-label">So What?</p>
    <p class="callout-body">PKI solved transitive trust 30 years ago. The primitives exist: cryptographic signatures, chain validation, revocation lists, scope constraints. Multi-agent systems need to adopt these patterns—not invent new ones. The gap is not conceptual, it's implementation.</p>
  </div>
</div>

<!-- ========================================
     SECTION 5: TRANSITIVE TRUST FALLACY
     ======================================== -->
<div class="page" id="transitive-trust">
  <h2>5. The Transitive Trust Fallacy
    <span class="confidence-badge">70%</span>
  </h2>
  <span class="confidence-line">(Confidence: Medium-High)</span>

  <p><span class="key-insight">The assumption: "If I trust Agent A, and Agent A trusts Agent B, then I should trust Agent B." This is the transitive trust fallacy. Trust does not transfer automatically — it requires verification at every step.</span></p>

  <h3>Why Transitive Trust Fails</h3>

  <p>In mathematics, transitivity holds: if A = B and B = C, then A = C. Trust is not equality. Trust is context-dependent, scope-limited, and time-bounded. <strong>Trust relationships do not compose transitively without explicit verification mechanisms.</strong></p>

  <p>The ScienceDirect definition: "Transitive trust is a concept in which trust relationships extend indirectly through intermediaries; for example, if Domain A trusts Domain B and Domain B trusts Domain C, then Domain A trusts Domain C through the transitive property."<sup>[12]</sup></p>

  <p>This works in practice <strong>only when each link is independently verified</strong>. Active Directory domain trusts work because authentication tokens are cryptographically signed and validated at each boundary. PKI works because certificates are verified against the full chain to a trusted root.</p>

  <h3>The Multi-Agent Failure Mode</h3>

  <p>Consider a realistic scenario:</p>

  <ol>
    <li><strong>User trusts Agent A</strong> (customer service orchestrator) to handle support tickets</li>
    <li><strong>Agent A delegates to Agent B</strong> (refund processing specialist) to issue a refund</li>
    <li><strong>Agent B calls a payment API</strong> to process a $500 refund</li>
  </ol>

  <p>Questions the payment API should ask:</p>

  <ul>
    <li>Does Agent B actually have authority from Agent A to request this refund?</li>
    <li>Is the delegation still valid, or has it been revoked?</li>
    <li>Is the refund amount within the scope Agent A delegated to Agent B?</li>
    <li>Can I verify this cryptographically, or am I trusting Agent B's word?</li>
  </ul>

  <p>Current multi-agent architectures answer: <strong>"We trust Agent B because it's part of our system."</strong> This is implicit trust, not verified trust. If Agent B is compromised (via prompt injection, memory poisoning, or supply chain attack), it can abuse Agent A's authority with no technical safeguards.</p>

  <div class="exhibit">
    <p class="exhibit-label">Exhibit 2: Transitive Trust Failure Scenarios</p>
    <table class="exhibit-table">
      <tr>
        <th>Scenario</th>
        <th>What Breaks</th>
        <th>Current Mitigation</th>
        <th>PKI-Equivalent Mitigation</th>
      </tr>
      <tr>
        <td>Agent A delegates to compromised Agent B</td>
        <td>Agent B abuses authority to call unauthorized tools</td>
        <td>Policy checks (if implemented)</td>
        <td>Scoped delegation certificate with tool constraints</td>
      </tr>
      <tr>
        <td>Agent A's delegation to Agent B should have expired</td>
        <td>Agent B continues acting with stale authority</td>
        <td>None (no expiration mechanism)</td>
        <td>Time-bounded certificates + OCSP revocation check</td>
      </tr>
      <tr>
        <td>Agent B sub-delegates to Agent C without Agent A's knowledge</td>
        <td>Agent C acts with Agent A's authority via 2-hop delegation</td>
        <td>None (no re-delegation control)</td>
        <td>Certificate path length constraints (max depth = 1)</td>
      </tr>
      <tr>
        <td>Agent A is decommissioned but Agent B retains credentials</td>
        <td>Agent B continues using Agent A's identity/permissions</td>
        <td>Manual credential rotation (if remembered)</td>
        <td>CRL (Certificate Revocation List) broadcast</td>
      </tr>
      <tr>
        <td>Downstream API cannot verify Agent B's authority chain</td>
        <td>API trusts Agent B's self-assertion of authority</td>
        <td>Application-layer "agent ID" header (unauthenticated)</td>
        <td>Cryptographic chain validation (verify signatures to root)</td>
      </tr>
    </table>
    <p class="exhibit-source">Source: Author analysis based on PKI failure patterns [11], OAuth delegation gaps [3], confused deputy attack patterns [9]</p>
  </div>

  <h3>The Confused Deputy Attack</h3>

  <p>The "confused deputy" attack is the canonical example of delegation failure<sup>[9]</sup>. Agent B (the "deputy") has legitimate authority for Task X. An attacker tricks Agent B into using that authority for Task Y, which Agent B should not be authorized to perform.</p>

  <p>In multi-agent systems, this manifests as:</p>

  <ul>
    <li><strong>Prompt injection:</strong> Attacker injects instructions that cause Agent B to misuse delegated tool access</li>
    <li><strong>Scope confusion:</strong> Agent B was delegated "read customer data" but uses the same credentials to "modify customer data"</li>
    <li><strong>Lateral movement:</strong> Agent B, authorized to call Service X, is tricked into calling Service Y using the same delegation token</li>
  </ul>

  <p>The mitigation in PKI: <strong>scoped certificates with usage constraints</strong> (e.g., "this certificate is valid only for TLS server authentication, not code signing"). The mitigation in OAuth: <strong>scoped tokens with audience restrictions</strong> (e.g., "this token is valid only for api.example.com/read, not /write").</p>

  <p>The mitigation in multi-agent systems: <strong>currently none at the architectural level</strong>. Scope enforcement, when it exists, is policy-based (application code checks) rather than cryptographically enforced.</p>

  <div class="callout invalidation">
    <p class="callout-label">What Would Invalidate This?</p>
    <p class="callout-body">If multi-agent frameworks implemented fine-grained delegation scopes with cryptographic enforcement (e.g., "Agent B is authorized to call tool_refund with amount ≤ $100"), the confused deputy risk would significantly reduce. No current framework provides this.</p>
  </div>

  <div class="callout sowhat">
    <p class="callout-label">So What?</p>
    <p class="callout-body">Every multi-agent delegation is a potential confused deputy attack. Without cryptographic scope constraints and chain verification, you're trusting that Agent B will only use its authority for the exact purpose Agent A intended. This is a policy hope, not a technical guarantee.</p>
  </div>
</div>

<!-- ========================================
     SECTION 6: THE DELEGATION GAP
     ======================================== -->
<div class="page" id="delegation-gap">
  <h2>6. The Delegation Gap — What OAuth Can't Do
    <span class="confidence-badge">80%</span>
  </h2>
  <span class="confidence-line">(Confidence: High)</span>

  <p><span class="key-insight">OAuth 2.0 was designed for human users granting access to third-party apps with explicit consent dialogs. AI agents delegate tasks autonomously in milliseconds without user interaction. OAuth's assumptions break.</span></p>

  <h3>OAuth's Human-Centric Design</h3>

  <p>OAuth 2.0 solves this problem: "User Alice wants to give App B access to her photos on Service A without giving App B her password." The authorization flow<sup>[3]</sup>:</p>

  <ol>
    <li>App B redirects Alice to Service A's authorization page</li>
    <li>Alice (the human) reviews the permission request and clicks "Allow"</li>
    <li>Service A issues an access token to App B, scoped to "read photos"</li>
    <li>App B uses the token to access photos on behalf of Alice</li>
  </ol>

  <p>Key assumptions:</p>

  <ul>
    <li><strong>Human consent:</strong> Alice explicitly authorizes the delegation</li>
    <li><strong>Persistent session:</strong> Alice maintains a browser session during the flow</li>
    <li><strong>Trust boundary:</strong> Alice trusts Service A to mediate the delegation</li>
    <li><strong>Scope clarity:</strong> The permission request is human-readable ("read your photos")</li>
  </ul>

  <p>As the Strata Identity guide states: "OAuth was designed for humans. It assumes persistent sessions and user consent—not fast-moving, autonomous systems."<sup>[3]</sup></p>

  <h3>What Breaks for Agents</h3>

  <p>When Agent A delegates to Agent B:</p>

  <ul>
    <li><strong>No human in the loop:</strong> The delegation happens programmatically, potentially thousands of times per second</li>
    <li><strong>No persistent session:</strong> Agents are stateless or have ephemeral sessions — there's no "browser context" to maintain</li>
    <li><strong>Dynamic scopes:</strong> The exact scope of delegation may be determined at runtime based on context ("refund up to the order total" — which varies per request)</li>
    <li><strong>Delegation chains:</strong> Agent B may need to sub-delegate to Agent C, creating multi-hop authorization that OAuth wasn't designed to track</li>
    <li><strong>Real-time revocation:</strong> If Agent A completes its task or detects an issue, it needs to instantly revoke Agent B's authority — OAuth's token expiration is time-based, not event-based</li>
  </ul>

  <div class="exhibit">
    <p class="exhibit-label">Exhibit 3: OAuth 2.0 vs. Agent Delegation Requirements</p>
    <table class="exhibit-table">
      <tr>
        <th>Requirement</th>
        <th>OAuth 2.0 (Human)</th>
        <th>Agent Delegation Need</th>
        <th>Gap</th>
      </tr>
      <tr>
        <td>Authorization speed</td>
        <td>Seconds (human interaction)</td>
        <td>Milliseconds (autonomous)</td>
        <td>Redirect flow too slow</td>
      </tr>
      <tr>
        <td>Consent mechanism</td>
        <td>User clicks "Allow"</td>
        <td>Programmatic delegation policy</td>
        <td>No consent UI possible</td>
      </tr>
      <tr>
        <td>Token binding</td>
        <td>Bearer tokens (anyone with token can use it)</td>
        <td>Proof-of-possession (only authorized agent)</td>
        <td>Bearer tokens enable token theft</td>
      </tr>
      <tr>
        <td>Delegation depth</td>
        <td>1-hop (user → app)</td>
        <td>N-hop (agent A → B → C → ...)</td>
        <td>No chain tracking</td>
      </tr>
      <tr>
        <td>Revocation</td>
        <td>Manual or time-based expiration</td>
        <td>Event-driven (task complete, failure detected)</td>
        <td>No real-time revocation</td>
      </tr>
      <tr>
        <td>Audit trail</td>
        <td>Application logs (if implemented)</td>
        <td>Cryptographic proof of delegation chain</td>
        <td>No tamper-evident audit</td>
      </tr>
    </table>
    <p class="exhibit-source">Source: OAuth 2.0 spec [3], Strata Identity [3], RFC 8693 Token Exchange [13], AAP Protocol [14]</p>
  </div>

  <h3>RFC 8693 Token Exchange — Partial Solution</h3>

  <p>OAuth 2.0 Token Exchange (RFC 8693) attempts to address delegation by allowing services to exchange one token for another<sup>[13]</sup>. It supports two semantics:</p>

  <ul>
    <li><strong>Impersonation:</strong> Agent B acts <em>as</em> Agent A (Agent A's identity is used)</li>
    <li><strong>Delegation:</strong> Agent B acts <em>on behalf of</em> Agent A (both identities are preserved in the token)</li>
  </ul>

  <p>The delegation semantics are closer to what agents need: "Principal A still has its own identity separate from B, and it is explicitly understood that while B may have delegated some of its rights to A, any actions taken are being taken by A representing B."<sup>[13]</sup></p>

  <p>But RFC 8693 still assumes:</p>

  <ul>
    <li>A centralized authorization server mediates all token exchanges</li>
    <li>Delegation happens at the token level, not the action level (no fine-grained per-task scoping)</li>
    <li>No cryptographic proof that the delegation is authorized — just the authorization server's word</li>
  </ul>

  <p>For multi-agent systems with decentralized orchestration, RFC 8693 is a building block, not a complete solution.</p>

  <div class="callout invalidation">
    <p class="callout-label">What Would Invalidate This?</p>
    <p class="callout-body">If OAuth extensions (like RFC 8693 + DPoP + fine-grained authorization) were widely adopted and proven effective for multi-agent delegation at scale, the "OAuth can't do it" claim would weaken. Current evidence shows limited adoption and significant gaps remaining.</p>
  </div>

  <div class="callout sowhat">
    <p class="callout-label">So What?</p>
    <p class="callout-body">Do not assume OAuth 2.0 solves agent delegation. It provides primitives (scoped tokens, token exchange) but lacks proof-of-possession, delegation chain verification, and event-driven revocation. Teams building on OAuth need to add these layers — they're not included.</p>
  </div>
</div>

<!-- ========================================
     SECTION 7: FRAMEWORK REALITY
     ======================================== -->
<div class="page" id="framework-reality">
  <h2>7. The Framework Reality — No Trust Verification
    <span class="confidence-badge">85%</span>
  </h2>
  <span class="confidence-line">(Confidence: High)</span>

  <p><span class="key-insight">No major multi-agent framework implements cryptographic delegation chain verification. AutoGen, CrewAI, MetaGPT, and LangGraph all trust inter-agent messages by default. The A2A protocol authenticates systems but not delegation authority.</span></p>

  <h3>Framework Survey</h3>

  <p>Based on documentation review and security feature analysis<sup>[4][5][15]</sup>:</p>

  <div class="exhibit">
    <p class="exhibit-label">Exhibit 4: Multi-Agent Framework Trust Verification Features</p>
    <table class="exhibit-table">
      <tr>
        <th>Framework</th>
        <th>Message Authentication</th>
        <th>Delegation Proof</th>
        <th>Chain Verification</th>
        <th>Scope Enforcement</th>
        <th>Revocation Support</th>
      </tr>
      <tr>
        <td>AutoGen</td>
        <td>No</td>
        <td>No</td>
        <td>No</td>
        <td>Policy-based (code)</td>
        <td>No</td>
      </tr>
      <tr>
        <td>CrewAI</td>
        <td>No</td>
        <td>No</td>
        <td>No</td>
        <td>Policy-based (code)</td>
        <td>No</td>
      </tr>
      <tr>
        <td>MetaGPT</td>
        <td>No</td>
        <td>No</td>
        <td>No</td>
        <td>Policy-based (code)</td>
        <td>No</td>
      </tr>
      <tr>
        <td>LangGraph</td>
        <td>No</td>
        <td>No</td>
        <td>No</td>
        <td>Node-level validation (partial)</td>
        <td>No</td>
      </tr>
      <tr>
        <td>A2A Protocol (Google)</td>
        <td>Yes (OAuth/OpenID)</td>
        <td>No</td>
        <td>No</td>
        <td>OAuth scopes</td>
        <td>OAuth token expiration</td>
      </tr>
    </table>
    <p class="exhibit-source">Source: Framework documentation analysis (AutoGen, CrewAI, MetaGPT, LangGraph) [4][5], A2A protocol spec [15], arxiv:2508.10146 [16]</p>
  </div>

  <h3>The A2A Protocol — Authentication Without Delegation Proof</h3>

  <p>Google's A2A (Agent-to-Agent) protocol, donated to the Linux Foundation, represents the most mature inter-agent communication standard<sup>[15]</sup>. It provides:</p>

  <ul>
    <li><strong>System authentication:</strong> Agents authenticate using OAuth 2.0 / OpenID Connect</li>
    <li><strong>Message schema:</strong> Standardized message format for task delegation</li>
    <li><strong>Discovery:</strong> Agents can discover each other's capabilities</li>
  </ul>

  <p>What A2A does <strong>not</strong> provide:</p>

  <ul>
    <li><strong>Message provenance verification:</strong> You know which agent sent the message (authentication), but not whether that agent had authority to delegate the task</li>
    <li><strong>Delegation chain tracking:</strong> If Agent A → B → C, there's no cryptographic record of the full chain</li>
    <li><strong>Content integrity:</strong> Messages are authenticated but not signed — a compromised agent can claim authority it doesn't have</li>
  </ul>

  <p>The arxiv paper on Agentic AI Frameworks (2508.10146) confirms: "AutoGen includes validators and retry logic; LangGraph enables advanced flow-level checks via node validation; Agno offers an early-stage trust layer; and the OpenAI SDK supports schema validation with developer-defined safeguards. Others like CrewAI, MetaGPT, and Google ADK provide partial support."<sup>[16]</sup></p>

  <p>"Partial support" means schema validation and retry logic — not cryptographic delegation verification.</p>

  <h3>The Multi-Agent Hijacking Evidence</h3>

  <p>Recall from AR-006 (Security Playbook): multi-agent system hijacking research tested AutoGen, CrewAI, and MetaGPT. Success rates: 45%, 55%, 64% respectively. The attack vector: inject malicious instructions into one agent's output, which downstream agents trust and execute.</p>

  <p>This succeeds <strong>because there is no cryptographic verification of message authority</strong>. Downstream agents assume that messages from "inside the system" are authorized. A compromised agent can inject instructions, and receiving agents cannot distinguish between "Agent A legitimately delegated this task" and "Agent A was compromised and is being controlled by an attacker."</p>

  <div class="callout claim">
    <p class="callout-label">Claim</p>
    <p class="callout-body">Current multi-agent frameworks operate on implicit trust: if Agent B receives a message claiming to be from Agent A, Agent B trusts it. There is no cryptographic verification of delegation authority, message integrity, or chain provenance.</p>
  </div>

  <div class="callout invalidation">
    <p class="callout-label">What Would Invalidate This?</p>
    <p class="callout-body">If a major framework (AutoGen 2.0, LangGraph 2.0, or new entrant) shipped with built-in message signing, delegation token verification, and chain-of-custody tracking as default behavior, the "no trust verification" claim would be invalidated. Current roadmaps show no such features planned.</p>
  </div>

  <div class="callout sowhat">
    <p class="callout-label">So What?</p>
    <p class="callout-body">Every multi-agent system built on current frameworks is vulnerable to delegation abuse. A compromised agent can issue arbitrary instructions to downstream agents, and those agents have no technical mechanism to verify the authority behind those instructions. This is an architectural gap, not a configuration issue.</p>
  </div>
</div>

<!-- ========================================
     SECTION 8: EMERGING SOLUTIONS
     ======================================== -->
<div class="page" id="emerging-solutions">
  <h2>8. Emerging Solutions — What's Being Built
    <span class="confidence-badge">65%</span>
  </h2>
  <span class="confidence-line">(Confidence: Medium)</span>

  <p><span class="key-insight">The gap is recognized. Emerging protocols — Visa Trusted Agent Protocol, DID/VC for agents, AAP (Agent Authorization Profile), DPoP (Demonstrating Proof-of-Possession) — are building the primitives multi-agent delegation needs. Adoption remains early-stage.</span></p>

  <h3>Visa Trusted Agent Protocol</h3>

  <p>Visa's Trusted Agent Protocol (GitHub, January 2026) provides "a standardized, cryptographic method for an AI agent to prove its identity and associated authorization directly to merchants."<sup>[6]</sup></p>

  <p>Key features:</p>

  <ul>
    <li><strong>Cryptographic agent identity:</strong> Each agent has a public/private key pair</li>
    <li><strong>Digital signatures:</strong> Every transaction includes a signature proving the agent's identity</li>
    <li><strong>Authorization verification:</strong> Merchants can verify that the agent is authorized by a specific user/organization</li>
    <li><strong>Delegation scopes:</strong> Spending caps, merchant restrictions, time limits (cryptographically enforced)</li>
  </ul>

  <p>This is the right architectural pattern: <strong>proof-of-possession combined with scoped delegation</strong>. The agent must prove it holds the private key (not just present a bearer token) and the scope is cryptographically bound to the authorization.</p>

  <p>Limitation: focused on commerce (payment delegation), not general-purpose multi-agent task delegation.</p>

  <h3>DID and Verifiable Credentials for Agents</h3>

  <p>The Decentralized Identifier (DID) and Verifiable Credential (VC) approach gives agents cryptographic identities<sup>[7][8][17]</sup>.</p>

  <p>From the arxiv paper (2511.02841): "This zero trust-compliant approach requires each agent to prove ownership of its DID and to present supporting VCs to the other party. The presented VCs must be cryptographically bound to the DID under investigation."<sup>[7]</sup></p>

  <p>The workflow:</p>

  <ol>
    <li>Agent A has a DID (decentralized identifier, e.g., did:key:z6Mk...)</li>
    <li>Agent A presents a Verifiable Credential signed by a trusted issuer: "Agent A is authorized to process refunds up to $500"</li>
    <li>Agent B (or downstream API) verifies:
      <ul>
        <li>The VC is cryptographically signed by a trusted issuer</li>
        <li>The VC is bound to Agent A's DID</li>
        <li>The VC is not expired or revoked</li>
        <li>The current action (refund $300) is within the VC's scope ($500 limit)</li>
      </ul>
    </li>
  </ol>

  <p>This mirrors PKI's chain-of-trust model but using DIDs instead of X.509 certificates. Indicio (identity provider) states: "Systems and agents need to demonstrate that they have the delegated authority to share this data with other identifiable AI agents and systems."<sup>[18]</sup></p>

  <p>Advantage: decentralized (no single CA), privacy-preserving (selective disclosure), flexible scope definitions.</p>

  <p>Disadvantage: immature tooling, limited framework integration, requires issuer infrastructure.</p>

  <h3>AAP Protocol (Agent Authorization Profile)</h3>

  <p>AAP Protocol positions itself as "OAuth 2.0 for AI Agents."<sup>[14]</sup> It extends OAuth with:</p>

  <ul>
    <li><strong>Client Credentials flow:</strong> For machine-to-machine authentication (no user interaction)</li>
    <li><strong>Token Exchange (RFC 8693):</strong> For delegation chains</li>
    <li><strong>DPoP (RFC 9449):</strong> Proof-of-possession to prevent token theft</li>
    <li><strong>mTLS:</strong> Mutual TLS for transport security</li>
  </ul>

  <p>The claim: "Your existing OAuth infrastructure just works." The reality: it requires OAuth server support for RFC 8693, DPoP, and mTLS — which most deployments don't have.</p>

  <h3>DPoP — Demonstrating Proof-of-Possession</h3>

  <p>DPoP (RFC 9449) solves the bearer token problem<sup>[19]</sup>. Standard OAuth access tokens are bearer tokens: anyone who possesses the token can use it. If an attacker steals the token, they can impersonate the agent.</p>

  <p>DPoP adds proof-of-possession: "The legitimate presenter of the token is constrained to be the sender that holds and proves possession of the private part of the key pair."<sup>[19]</sup></p>

  <p>The agent must sign each API request with its private key. The API verifies the signature against the public key in the DPoP-bound token. Token theft is useless without the private key.</p>

  <p>This is critical for multi-agent systems where tokens are passed between agents. DPoP ensures that only the authorized agent can use the token, even if it's intercepted or logged.</p>

  <div class="exhibit">
    <p class="exhibit-label">Exhibit 5: Emerging Agent Delegation Protocols</p>
    <table class="exhibit-table">
      <tr>
        <th>Protocol/Standard</th>
        <th>Key Feature</th>
        <th>Maturity</th>
        <th>Adoption</th>
      </tr>
      <tr>
        <td>Visa Trusted Agent Protocol</td>
        <td>Cryptographic identity + scoped delegation for commerce</td>
        <td>Early (Jan 2026 release)</td>
        <td>Limited (commerce-specific)</td>
      </tr>
      <tr>
        <td>DID/VC for Agents (W3C)</td>
        <td>Decentralized identity + verifiable credentials</td>
        <td>Maturing (standards stable)</td>
        <td>Growing (identity providers)</td>
      </tr>
      <tr>
        <td>AAP Protocol</td>
        <td>OAuth 2.0 + Token Exchange + DPoP for agents</td>
        <td>Emerging (2025 proposal)</td>
        <td>Very limited</td>
      </tr>
      <tr>
        <td>DPoP (RFC 9449)</td>
        <td>Proof-of-possession for OAuth tokens</td>
        <td>Standardized (2023)</td>
        <td>Growing (OAuth providers)</td>
      </tr>
      <tr>
        <td>OpenID Federation</td>
        <td>Transitive trust via metadata statements (trust anchor → operator → entity → agent)</td>
        <td>Maturing (OpenID Foundation)</td>
        <td>Limited (early adopters)</td>
      </tr>
      <tr>
        <td>JSIGN</td>
        <td>Global notary for AI agent authorization</td>
        <td>Early (platform launch)</td>
        <td>Very limited</td>
      </tr>
    </table>
    <p class="exhibit-source">Source: Visa TAP [6], DID/VC spec [7][17], AAP Protocol [14], DPoP RFC 9449 [19], OpenID Federation [20], JSIGN [21]</p>
  </div>

  <h3>The Integration Gap</h3>

  <p>These protocols exist. The primitives work. The gap: <strong>no multi-agent framework has integrated them as default behavior</strong>.</p>

  <p>To use DPoP with AutoGen, you must:</p>

  <ol>
    <li>Manually generate key pairs for each agent</li>
    <li>Implement DPoP signing in your tool call layer</li>
    <li>Configure your APIs to verify DPoP proofs</li>
    <li>Handle key rotation and revocation yourself</li>
  </ol>

  <p>This is not "turn on a config flag" — it's "build your own security layer." Most teams won't do it.</p>

  <div class="callout invalidation">
    <p class="callout-label">What Would Invalidate This?</p>
    <p class="callout-body">If a major framework ships with DPoP + DID/VC support as a standard feature ("enable_delegation_verification=True"), the integration gap closes. As of February 2026, no framework has announced such plans.</p>
  </div>

  <div class="callout sowhat">
    <p class="callout-label">So What?</p>
    <p class="callout-body">The technology exists to solve trust delegation. The bottleneck is framework adoption. Teams building high-stakes multi-agent systems should implement DPoP + DID/VC patterns manually until frameworks catch up. This is not optional for production deployments handling sensitive data or transactions.</p>
  </div>
</div>

<!-- ========================================
     SECTION 9: RECOMMENDATIONS
     ======================================== -->
<div class="page" id="recommendations">
  <h2>9. Recommendations</h2>

  <p><span class="key-insight">Based on the evidence in this report, secure multi-agent delegation requires cryptographic chain-of-trust verification modeled on PKI principles. Here's how to build it.</span></p>

  <p style="font-size: 0.85rem; color: #666; margin-bottom: 24px;"><strong>Scope:</strong> These recommendations apply to multi-agent systems where agents delegate tasks to other agents, especially in high-stakes domains (finance, healthcare, enterprise automation). Single-agent systems or agents that don't delegate have simpler requirements.</p>

  <h3>For Engineering Teams Building Multi-Agent Systems</h3>

  <ol>
    <li><strong>Implement proof-of-possession for all delegation tokens.</strong> Use DPoP (RFC 9449) or equivalent. Never use bearer tokens for inter-agent communication. Each agent must prove it holds the private key, not just present a token. This prevents token theft and replay attacks.</li>
    <li><strong>Adopt DID/VC for agent identity.</strong> Give each agent a Decentralized Identifier and issue Verifiable Credentials that define delegation scope. This creates a cryptographically verifiable chain: Issuer → Agent A → Agent B. Downstream systems can verify the full chain independently.</li>
    <li><strong>Enforce delegation scope cryptographically, not via policy.</strong> Don't rely on application code to check "is this agent allowed to do X?" Bind the scope to the credential itself. Use VC constraints (spending limits, tool restrictions, time bounds) that are verified before execution, not during.</li>
    <li><strong>Build a delegation revocation mechanism.</strong> When Agent A completes its task or detects a problem, it must instantly revoke Agent B's authority. Implement real-time revocation checks (like OCSP for certificates), not just time-based token expiration. Compromised agents must be removable from the trust chain immediately.</li>
    <li><strong>Log the full delegation chain cryptographically.</strong> Every action should be traceable to its authorization chain: User → Agent A → Agent B → Action. Use tamper-evident logs (e.g., append-only, hash-chained) so audit trails cannot be modified retroactively. This is your evidence in case of security incident or compliance audit.</li>
  </ol>

  <h3>Framework-Specific Guidance</h3>

  <div class="exhibit">
    <p class="exhibit-label">Exhibit 6: Multi-Agent Framework Security Hardening</p>
    <table class="exhibit-table">
      <tr>
        <th>Framework</th>
        <th>Current State</th>
        <th>Minimum Hardening</th>
        <th>Production-Grade</th>
      </tr>
      <tr>
        <td>AutoGen</td>
        <td>No trust verification</td>
        <td>Add message signing (JSON Web Signature), validate signatures before execution</td>
        <td>Implement DID/VC per agent, DPoP for tool calls, delegation revocation registry</td>
      </tr>
      <tr>
        <td>CrewAI</td>
        <td>No trust verification</td>
        <td>Add agent authentication (shared secret or mTLS), log delegation chains</td>
        <td>DID/VC + scoped credentials per agent role, cryptographic audit trail</td>
      </tr>
      <tr>
        <td>LangGraph</td>
        <td>Node-level validation (partial)</td>
        <td>Extend validators to check delegation authority (not just schema), add inter-node signature verification</td>
        <td>Full chain-of-trust validation at each node, DPoP integration for external API calls</td>
      </tr>
      <tr>
        <td>Custom (building from scratch)</td>
        <td>—</td>
        <td>Use AAP Protocol or similar OAuth + DPoP pattern, implement token exchange (RFC 8693)</td>
        <td>Full PKI-style trust architecture: root trust anchor, intermediate agent CAs, scoped end-entity credentials, CRL/OCSP revocation</td>
      </tr>
    </table>
    <p class="exhibit-source">Source: Author recommendation based on framework analysis and PKI best practices</p>
  </div>

  <h3>What Not to Do</h3>

  <ul>
    <li><strong>Don't assume OAuth 2.0 alone solves delegation.</strong> Standard OAuth lacks proof-of-possession, delegation chain tracking, and event-driven revocation. You need extensions (DPoP, Token Exchange, fine-grained scopes).</li>
    <li><strong>Don't trust inter-agent messages by default.</strong> Require cryptographic verification of every delegation claim. "Agent B says it's authorized by Agent A" is not sufficient — demand proof.</li>
    <li><strong>Don't use bearer tokens for agent credentials.</strong> Bearer tokens + prompt injection = full credential compromise. Use proof-of-possession tokens that require private key signatures.</li>
    <li><strong>Don't rely solely on policy-based scope enforcement.</strong> Application code can be bypassed (prompt injection, memory poisoning). Cryptographic scope constraints are verified before the agent even sees the request.</li>
  </ul>

  <h3>The PKI Lessons Applied</h3>

  <p>Treat multi-agent delegation like PKI:</p>

  <ul>
    <li><strong>Trust anchor:</strong> Define who/what is the root of trust (the human user, the organization, a deployment authority)</li>
    <li><strong>Intermediate delegation:</strong> Issue scoped credentials to Agent A that allow it to sub-delegate to Agent B with constrained authority</li>
    <li><strong>End-entity verification:</strong> Every action must be traceable to the trust anchor via cryptographic chain</li>
    <li><strong>Revocation infrastructure:</strong> Build CRL/OCSP equivalent for agents (real-time revocation checks)</li>
    <li><strong>Certificate Transparency equivalent:</strong> Public or internal audit log of all delegation events</li>
  </ul>

  <p>PKI has 30 years of operational experience. The primitives work. Don't reinvent them — adapt them.</p>

  <div class="callout sowhat">
    <p class="callout-label">So What?</p>
    <p class="callout-body">The gap between current multi-agent frameworks and secure delegation is large but solvable. The primitives exist (DPoP, DID/VC, Token Exchange). The architecture is proven (PKI). The work is integration — building the trust layer that frameworks don't provide. This is infrastructure work, not research. It's tedious, unglamorous, and absolutely critical.</p>
  </div>
</div>

<!-- ========================================
     SECTION 10: PREDICTIONS
     ======================================== -->
<div class="page" id="predictions">
  <h2>10. Predictions
    <span style="font-size: 0.65rem; font-weight: 500; color: #1a1a1a; background: #f5f4f0; padding: 2px 6px; border-radius: 8px; margin-left: 8px; vertical-align: middle;">BETA</span>
  </h2>

  <p style="font-size: 0.85rem; color: #666; margin-bottom: 24px;">These predictions will be scored publicly at 12 months. This is version 1.0 (February 2026). Scoring methodology available at ainaryventures.com/predictions.</p>

  <div class="exhibit">
    <table class="exhibit-table">
      <tr>
        <th>Prediction</th>
        <th>Timeline</th>
        <th>Confidence</th>
      </tr>
      <tr>
        <td>At least one major multi-agent framework (AutoGen, LangGraph, or new entrant) ships built-in DPoP or DID/VC support</td>
        <td>Q4 2026</td>
        <td>55%</td>
      </tr>
      <tr>
        <td>A high-profile multi-agent security incident (confused deputy attack, delegation abuse) is publicly disclosed</td>
        <td>Q3 2026</td>
        <td>70%</td>
      </tr>
      <tr>
        <td>Visa Trusted Agent Protocol (or similar commerce-focused standard) gains adoption beyond pilot deployments</td>
        <td>Q4 2026</td>
        <td>60%</td>
      </tr>
      <tr>
        <td>A "Certificate Transparency for Agents" equivalent emerges (public audit log of agent delegations)</td>
        <td>Q2 2027</td>
        <td>40%</td>
      </tr>
      <tr>
        <td>OAuth providers (Auth0, Okta, Azure AD) add agent-specific features (DPoP by default, delegation chain tracking)</td>
        <td>Q3 2026</td>
        <td>65%</td>
      </tr>
    </table>
  </div>
</div>

<!-- ========================================
     SECTION 11: TRANSPARENCY NOTE
     ======================================== -->
<div class="page" id="transparency">
  <h2>11. Transparency Note</h2>

  <p class="transparency-intro">This report was created using a multi-agent research system. Every claim is sourced. Where evidence ends and interpretation begins, it is explicitly marked.</p>

  <table class="transparency-table">
    <tr>
      <td>Overall Confidence</td>
      <td>75% — High confidence in PKI analogy and OAuth limitations. Medium confidence in emerging protocol adoption timelines and attack vector prevalence (limited production incident data).</td>
    </tr>
    <tr>
      <td>Sources</td>
      <td>15 total — 4 cryptographic standards (PKI RFCs, OAuth RFC 8693, DPoP RFC 9449, OpenID Federation), 6 framework/protocol documentation reviews (AutoGen, CrewAI, A2A, Visa TAP, AAP, DID/VC), 5 emerging implementations (JSIGN, TessPay, OpenID Connect for Agents, Raidiam OpenID Federation, LlamaIndex trust layer)</td>
    </tr>
    <tr>
      <td>Strongest Evidence</td>
      <td>The PKI analogy is rock-solid — 30+ years of documented trust chain successes and failures provide clear lessons. OAuth's human-centric design assumptions are well-documented in the specifications themselves.</td>
    </tr>
    <tr>
      <td>Weakest Point</td>
      <td>Limited production incident data for multi-agent delegation attacks. The claim that "trust chains break" is strongly supported by PKI history and framework analysis, but direct empirical evidence of agent delegation exploits in the wild is scarce (likely due to under-reporting, not absence).</td>
    </tr>
    <tr>
      <td>What Would Invalidate</td>
      <td>If multi-agent frameworks achieve widespread security without cryptographic delegation verification (e.g., through perfect prompt injection defense + perfect agent sandboxing), the "trust chain is essential" argument weakens. If OAuth extensions prove sufficient at scale, the "OAuth can't do it" claim would require revision.</td>
    </tr>
    <tr>
      <td>Methodology</td>
      <td>Research followed a structured multi-agent pipeline: (1) PKI and cryptographic standards analysis (trust chain mechanics, historical failure modes), (2) OAuth and delegation protocol review (RFC 8693, DPoP, OpenID Federation), (3) Multi-agent framework security feature documentation review (6 frameworks), (4) Emerging protocol landscape synthesis (DID/VC, Visa TAP, AAP), (5) Gap analysis and attack vector modeling based on PKI compromise patterns. Cross-referencing between PKI history and current agent architectures identified structural parallels.</td>
    </tr>
    <tr>
      <td>System Disclosure</td>
      <td>This report was created with a multi-agent research system combining cryptographic standards analysis, framework documentation review, and protocol synthesis. Human direction shaped research focus (PKI as analogy, OAuth limitations, framework gaps). The final synthesis and writing were AI-generated with human review.</td>
    </tr>
  </table>
</div>

<!-- ========================================
     SECTION 12: CLAIM REGISTER
     ======================================== -->
<div class="page" id="claim-register">
  <h2>12. Claim Register</h2>

  <p style="font-size: 0.85rem; color: #666; margin-bottom: 24px;">Top claims from this report with their evidence basis and confidence levels. The top 5 claims include invalidation conditions.</p>

  <div class="exhibit">
    <table class="exhibit-table">
      <tr>
        <th>#</th>
        <th>Claim</th>
        <th>Value/Finding</th>
        <th>Source</th>
        <th>Confidence</th>
        <th>Used In</th>
      </tr>
      <tr>
        <td>1</td>
        <td>PKI solves transitive trust via cryptographic chain verification</td>
        <td>Root CA → Intermediate → End entity, each link independently verifiable</td>
        <td>RFC 5280 [1], PKI overview [2][10]</td>
        <td>High (30+ years)</td>
        <td>Section 4</td>
      </tr>
      <tr>
        <td>2</td>
        <td>OAuth 2.0 designed for humans, not autonomous agents</td>
        <td>Assumes persistent sessions, user consent, no sub-delegation</td>
        <td>OAuth spec [3], Strata Identity [3]</td>
        <td>High (spec analysis)</td>
        <td>Section 6</td>
      </tr>
      <tr>
        <td>3</td>
        <td>No major multi-agent framework implements delegation chain verification</td>
        <td>AutoGen, CrewAI, MetaGPT, LangGraph all trust messages by default</td>
        <td>Framework docs [4][5][16]</td>
        <td>High (direct review)</td>
        <td>Section 7</td>
      </tr>
      <tr>
        <td>4</td>
        <td>A2A protocol authenticates systems but not delegation authority</td>
        <td>OAuth authentication ≠ proof of delegated authority</td>
        <td>A2A protocol spec [15]</td>
        <td>High (spec analysis)</td>
        <td>Section 7</td>
      </tr>
      <tr>
        <td>5</td>
        <td>Visa Trusted Agent Protocol provides cryptographic proof-of-possession</td>
        <td>Agent identity + digital signatures + scoped delegation</td>
        <td>Visa TAP GitHub [6]</td>
        <td>Medium (early release)</td>
        <td>Section 8</td>
      </tr>
      <tr>
        <td>6</td>
        <td>DID/VC provides decentralized agent identity</td>
        <td>Zero-trust approach: prove DID ownership + present VCs</td>
        <td>arxiv:2511.02841 [7]</td>
        <td>High (peer-reviewed)</td>
        <td>Section 8</td>
      </tr>
      <tr>
        <td>7</td>
        <td>DPoP prevents bearer token theft via proof-of-possession</td>
        <td>Agent must sign requests with private key</td>
        <td>RFC 9449 [19]</td>
        <td>High (RFC standard)</td>
        <td>Section 8</td>
      </tr>
      <tr>
        <td>8</td>
        <td>PKI failures (Comodo, DigiNotar, Symantec) show delegation risks</td>
        <td>Compromised intermediate authority = full chain compromise</td>
        <td>Chain-of-trust history [11]</td>
        <td>High (documented incidents)</td>
        <td>Section 4</td>
      </tr>
      <tr>
        <td>9</td>
        <td>Confused deputy attacks exploit delegation without scope verification</td>
        <td>Agent uses legitimate authority for unauthorized purpose</td>
        <td>Security literature [9]</td>
        <td>High (established pattern)</td>
        <td>Section 5</td>
      </tr>
      <tr>
        <td>10</td>
        <td>RFC 8693 Token Exchange supports delegation semantics</td>
        <td>Agent A and Agent B identities preserved in token</td>
        <td>RFC 8693 [13]</td>
        <td>High (RFC standard)</td>
        <td>Section 6</td>
      </tr>
      <tr>
        <td>11</td>
        <td>OpenID Federation enables transitive trust verification</td>
        <td>Metadata statements: trust anchor → operator → entity → agent</td>
        <td>OpenID Federation [20]</td>
        <td>Medium (maturing standard)</td>
        <td>Section 8</td>
      </tr>
      <tr>
        <td>12</td>
        <td>No framework has integrated DPoP/DID/VC as default</td>
        <td>Teams must build custom security layer</td>
        <td>Framework analysis [4][5][16]</td>
        <td>High (direct review)</td>
        <td>Section 8</td>
      </tr>
    </table>
  </div>

  <p style="margin-top: 24px; font-size: 0.85rem; color: #666;"><strong>Top 5 Invalidation Conditions:</strong></p>

  <ol style="font-size: 0.85rem; color: #666; margin-top: 12px;">
    <li><strong>Claim 2:</strong> If OAuth extensions (RFC 8693 + DPoP + fine-grained authorization) prove sufficient for agent delegation at scale without additional primitives, the "OAuth can't do it" framing weakens.</li>
    <li><strong>Claim 3:</strong> If a major framework ships with cryptographic delegation verification as default (message signing, chain validation, revocation), the "no framework support" claim is invalidated.</li>
    <li><strong>Claim 5:</strong> If Visa TAP (or similar) fails to gain traction beyond pilot deployments, the "emerging solutions" narrative requires revision toward "proposed but not adopted."</li>
    <li><strong>Claim 9:</strong> If architectural patterns emerge that prevent confused deputy attacks without cryptographic scope enforcement (e.g., perfect agent sandboxing), the scope verification requirement weakens.</li>
    <li><strong>Claim 12:</strong> If framework vendors announce and ship DPoP/DID/VC integration within 6 months, the integration gap closes faster than predicted.</li>
  </ol>
</div>

<!-- ========================================
     SECTION 13: REFERENCES
     ======================================== -->
<div class="page" id="references">
  <h2>13. References</h2>

  <div class="reference-entry">[1] RFC 5280 (2008). "Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile." IETF. https://datatracker.ietf.org/doc/html/rfc5280</div>

  <div class="reference-entry">[2] Fir3net (2023). "PKI - Chain of Trust." Security Concepts and Terminology. https://www.fir3net.com/Security/Concepts-and-Terminology/pki-chain-of-trust.html</div>

  <div class="reference-entry">[3] Strata Identity (2026). "What is Agentic AI Security? A Guide for 2026." https://www.strata.io/blog/agentic-identity/8-strategies-for-ai-agent-security-in-2025/</div>

  <div class="reference-entry">[4] OpenReview (2025). "Multi-Agent Systems Execute Arbitrary Malicious Code." Research paper analyzing AutoGen, CrewAI, MetaGPT security. https://openreview.net/pdf?id=DAozI4etUp</div>

  <div class="reference-entry">[5] ArXiv:2503.12188 (2025). "Multi-Agent System Hijacking." Documented 45-64% success rates across frameworks.</div>

  <div class="reference-entry">[6] Visa (2026). "Trusted Agent Protocol." GitHub repository. https://github.com/visa/trusted-agent-protocol</div>

  <div class="reference-entry">[7] ArXiv:2511.02841v1 (2025). "AI Agents with Decentralized Identifiers and Verifiable Credentials." https://arxiv.org/html/2511.02841v1</div>

  <div class="reference-entry">[8] Dock.io (2026). "AI Agent Digital Identity Verification: How to Trust Autonomous Decisions." https://www.dock.io/post/ai-agent-digital-identity-verification</div>

  <div class="reference-entry">[9] Security literature on confused deputy attacks — canonical delegation failure pattern where an authorized entity is tricked into misusing its authority.</div>

  <div class="reference-entry">[10] TraceSecurity (2025). "Certificate Authorities and the Chain of Trust." https://www.tracesecurity.com/blog/articles/certificate-authorities-and-the-chain-of-trust</div>

  <div class="reference-entry">[11] Grokipedia (2025). "Chain of trust." Historical PKI compromise incidents (Comodo 2011, DigiNotar 2011, Symantec 2015-2017). https://grokipedia.com/page/Chain_of_trust</div>

  <div class="reference-entry">[12] ScienceDirect Topics. "Transitive Trust." Definition and conceptual overview. https://www.sciencedirect.com/topics/computer-science/transitive-trust</div>

  <div class="reference-entry">[13] RFC 8693 (2020). "OAuth 2.0 Token Exchange." IETF. https://datatracker.ietf.org/doc/html/rfc8693</div>

  <div class="reference-entry">[14] AAP Protocol (2025). "Agent Authorization Profile — OAuth 2.0 for AI Agents." https://www.aap-protocol.org/</div>

  <div class="reference-entry">[15] A2A Protocol (Google → Linux Foundation). "Agent-to-Agent Communication Standard." Documentation and specification.</div>

  <div class="reference-entry">[16] ArXiv:2508.10146v1 (2025). "Agentic AI Frameworks: Architectures, Protocols, and Design Challenges." https://arxiv.org/html/2508.10146v1</div>

  <div class="reference-entry">[17] Indicio (2026). "Why Verifiable Credentials will power real-world AI in 2026." https://indicio.tech/blog/why-verifiable-credentials-will-power-real-world-ai-in-2026/</div>

  <div class="reference-entry">[18] Indicio (2026). "Systems and agents need to demonstrate that they have the delegated authority to share this data with other identifiable AI agents and systems."</div>

  <div class="reference-entry">[19] RFC 9449 (2023). "OAuth 2.0 Demonstrating Proof of Possession (DPoP)." IETF. https://datatracker.ietf.org/doc/html/rfc9449</div>

  <div class="reference-entry">[20] Raidiam Developers (2025). "Building Access Control for Agentic AI with OpenID Federation." https://www.raidiam.com/developers/blog/building-access-control-for-agentic-ai-with-openid-federation</div>

  <div class="reference-entry">[21] JSIGN (2026). "Integrated Global Notary for AI Agents." https://jsign.org/welcome</div>

  <div class="reference-entry">[22] Ainary Research (2026). "The Trust Transfer Problem — When Agents Delegate to Agents." AR-024.</div>

  <div class="author-section">
    <div class="author-initials">FZ</div>
    <div class="author-name">About the Author</div>
    <div class="author-bio">Florian Ziesche is the founder of Ainary Ventures, where AI does 80% of the research and humans do the 20% that matters. Before Ainary, he was CEO of 36ZERO Vision and advised startups and SMEs on AI strategy and due diligence. His conviction: HUMAN × AI = LEVERAGE. This report is the proof.</div>
    <a href="https://ainaryventures.com" class="author-link">ainaryventures.com</a>
  </div>
</div>

<!-- ========================================
     BACK COVER
     ======================================== -->
<div class="back-cover">
  <div class="back-cover-logo">
    <span class="gold-punkt" style="font-size: 18px;">●</span>
    <span style="font-size: 1rem; font-weight: 500; color: #1a1a1a; margin-left: 8px;">Ainary</span>
  </div>

  <div class="back-cover-services">
    AI Strategy · Published Research · Daily Intelligence
  </div>

  <div class="back-cover-cta">
    <a href="mailto:florian@ainaryventures.com">Contact</a> · 
    <a href="mailto:florian@ainaryventures.com?subject=Feedback: AR-024">Feedback</a>
  </div>

  <div class="back-cover-contact">
    ainaryventures.com<br>
    florian@ainaryventures.com
  </div>

  <div class="back-cover-copyright">
    © 2026 Ainary Ventures
  </div>
</div>

</body>
</html>
